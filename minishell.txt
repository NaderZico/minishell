==> expander.c <==
#include "minishell.h"

static char *expand_env_var(char *var_name, char **env)
{
    int i = 0;
    int len = ft_strlen(var_name);

    while (env[i])
    {
        if (ft_strncmp(env[i], var_name, len) == 0
            && env[i][len] == '=')
            return ft_strdup(env[i] + len + 1);
        i++;
    }
    return ft_strdup("");
}

char *expand_variable(char **result, char *ptr, t_data *data)
{
    char var_name[256];
    int  i = 0;

    ptr++;  // Skip the '$'

    if (*ptr == '?')
        var_name[i++] = *ptr++;
    else
        while (ft_isalnum(*ptr) || *ptr == '_')
            var_name[i++] = *ptr++;
    var_name[i] = '\0';

    /* If it was `$?`, expand to last status; otherwise look up in env. */
    char *expanded = (var_name[0] == '?' )
        ? ft_itoa(data->last_status)
        : expand_env_var(var_name, data->env);

    *result = ft_strjoin_free(*result, expanded, BOTH);
    return ptr;
}

// ===== expander.c (updated) =====
void expand_tokens(t_data *data) {
    for (int i = 0; i < data->token_count; i++) {
        t_token *token = &data->tokens[i];
        
        if (token->type != WORD || token->quote == SINGLE_QUOTE)
            continue;

        char *result = ft_strdup(""); // Initialize with empty string
        char *ptr = token->value;
        
        while (ptr && *ptr) {
            if (*ptr == '$' && (token->quote != SINGLE_QUOTE)) {
                ptr = expand_variable(&result, ptr, data);
            } else {
                char str[2] = {*ptr, '\0'};
                result = ft_strjoin_free(result, str, FIRST);
                ptr++;
            }
        }
        
        free(token->value);
        token->value = result;
    }
}
==> lexer.c <==
#include "minishell.h"

int ft_isspace(char c)
{
	return (c == ' ' || c == '\t' || c == '\n' || c == '\v' || c == '\f' || c == '\r');
}

char quote_type_to_char(t_quote type)
{
    if (type == SINGLE_QUOTE) return '\'';
    if (type == DOUBLE_QUOTE) return '"';
    return 0;
}

t_quote update_quote_state(t_quote current, char c)
{
    if (c == '\'')
        return (current == SINGLE_QUOTE) ? NO_QUOTE : SINGLE_QUOTE;
    if (c == '"')
        return (current == DOUBLE_QUOTE) ? NO_QUOTE : DOUBLE_QUOTE;
    return current;
}

static void handle_quotes(char *input, int *i, t_data *data)
{
    t_quote quote_type = input[*i] == '\'' ? SINGLE_QUOTE : DOUBLE_QUOTE;
    int start = ++(*i);
    
    while (input[*i] && input[*i] != quote_type_to_char(quote_type))
        (*i)++;
    
    char *value = ft_substr(input, start, *i - start);
    if (input[*i])
        (*i)++;
    else {
        ft_putstr_fd("minishell: unterminated quote\n", 2);
        free(value);
        return;
    }
    
    data->tokens[data->token_count++] = (t_token){
        .value = value,
        .type = WORD,
        .quote = quote_type
    };
}

static void handle_redir_pipe(char *input, int *i, t_data *data)
{
    t_token_type type = WORD;
    
    if (input[*i] == '|') {
        type = PIPE;
        (*i)++;
    }
    else if (input[*i] == '<') {
        if (input[*i + 1] == '<') {
            type = REDIR_HEREDOC;
            (*i) += 2;
        }
        else {
            type = REDIR_IN;
            (*i) += 1;
        }
    }
    else if (input[*i] == '>') {
        if (input[*i + 1] == '>') {
            type = REDIR_APPEND;
            (*i) += 2;
        }
        else {
            type = REDIR_OUT;
            (*i) += 1;
        }
    }
    data->tokens[data->token_count++] = (t_token){NULL, type, NO_QUOTE};
}

static void handle_word(char *input, int *i, t_data *data) {
    int start = *i;
    t_quote current_quote = NO_QUOTE;

    while (input[*i] && (current_quote != NO_QUOTE || 
           !ft_strchr(" |<>\"\'", input[*i]))) {
        if (input[*i] == '\'' || input[*i] == '"') {
            current_quote = update_quote_state(current_quote, input[*i]);
        }
        (*i)++;
    }
    
    char *value = ft_substr(input, start, *i - start);
    data->tokens[data->token_count++] = (t_token){
        .value = value,
        .type = WORD,
        .quote = NO_QUOTE
    };
}

int tokenize_input(char *input, t_data *data) {
    int i = 0;
    data->token_count = 0;
    
    while (input[i] && data->token_count < MAX_TOKENS - 1) {
        while (ft_isspace(input[i])) i++;
        if (!input[i]) break;

        if (input[i] == '|' || input[i] == '<' || input[i] == '>') {
            handle_redir_pipe(input, &i, data);
        }
        else if (input[i] == '\'' || input[i] == '"') {
            handle_quotes(input, &i, data);
        }
        else {
            handle_word(input, &i, data);
        }
    }
    return 0;
}

==> main.c <==
// #include "minishell.h"

// int main(int argc, char **argv, char **envp)
// {
//     t_data  data = {
//         .token_count = 0,
//         .cmd_count = 0,
//         .env = envp,
//         .last_status = 0
//     };
//     char    *input;

//     (void)argc;
//     (void)argv;
//     setup_signals();
//     while (1)
//     {
//         input = readline("minishell> ");
//         if (!input)
//         {
//             write(1, "exit\n", 5);
//             break;
//         }
//         if (*input)
//         {
//             add_history(input);
//             if (tokenize_input(input, &data) == 0 && validate_syntax(&data))
//             {
//                 expand_tokens(&data);
//                 parse_tokens(&data);
//             }
//             free(input);
//             free_data(&data);
//         }
//     }
//     return (0);
// }

#include "minishell.h"
#include <stdio.h>   // for printf
#include <stdlib.h>  // for free

/**
 * Print out all tokens for inspection.
 */
static void debug_print_tokens(t_data *data)
{
    printf("→ [debug] token_count = %d\n", data->token_count);
    for (int i = 0; i < data->token_count; i++)
    {
        t_token *tok = &data->tokens[i];
        printf("   token[%d]: type=%d, quote=%d, value=\"%s\"\n",
               i, tok->type, tok->quote, tok->value);
    }
}

/**
 * Print out all parsed commands, their args and redirections.
 */
static void debug_print_commands(t_data *data)
{
    printf("→ [debug] cmd_count   = %d\n", data->cmd_count);
    for (int c = 0; c < data->cmd_count; c++)
    {
        t_command *cmd = &data->commands[c];
        printf("   command[%d]:\n", c);

        if (cmd->args)
        {
            for (int j = 0; cmd->args[j]; j++)
                printf("      arg[%d] = \"%s\"\n", j, cmd->args[j]);
        }
        else
            printf("      (no args)\n");

        for (int r = 0; r < cmd->redir_count; r++)
        {
            printf("      redir[%d]: type=%d, file=\"%s\"\n",
                   r, cmd->redirs[r].type, cmd->redirs[r].file);
        }
    }
}

int main(int argc, char **argv, char **envp)
{
    t_data  data = {
        .token_count = 0,
        .cmd_count   = 0,
        .env         = envp,
        .last_status = 0
    };
    char    *input;

    (void)argc;
    (void)argv;
    setup_signals();

    while (1)
    {
        input = readline("minishell> ");
        if (!input)
        {
            write(1, "exit\n", 5);
            break;
        }

        if (*input)
        {
            add_history(input);
            if (tokenize_input(input, &data) == 0
                && validate_syntax(&data))
            {
                // Debug dump: raw tokens
                debug_print_tokens(&data);

                // Expand $vars, then parse into commands
                expand_tokens(&data);
                parse_tokens(&data);

                // Debug dump: parsed commands/redirects
                debug_print_commands(&data);
            }
            free(input);
            free_data(&data);
        }
    }
    return (0);
}

==> parser.c <==
#include "minishell.h"

static int	add_redirection(t_command *cmd, t_data *data, int *i)
{
	t_redir	*new_redirs;
	int		j;

	new_redirs = safe_malloc(sizeof(t_redir) * (cmd->redir_count + 1));
	j = -1;
	while (++j < cmd->redir_count)
		new_redirs[j] = cmd->redirs[j];
	
	new_redirs[cmd->redir_count].type = data->tokens[*i].type;
	new_redirs[cmd->redir_count].file = ft_strdup(data->tokens[*i + 1].value);
	
	free(cmd->redirs);
	cmd->redirs = new_redirs;
	cmd->redir_count++;
	*i += 2;
	return (0);
}

int	parse_tokens(t_data *data)
{
	int	cmd_idx = 0;
	int	i = 0;

	data->cmd_count = 0;
	while (i < data->token_count && cmd_idx < MAX_COMMANDS)
	{
		data->commands[cmd_idx].args = NULL;
		data->commands[cmd_idx].redirs = NULL;
		data->commands[cmd_idx].redir_count = 0;
		
		while (i < data->token_count && data->tokens[i].type != PIPE)
		{
			if (data->tokens[i].type >= REDIR_IN)
				add_redirection(&data->commands[cmd_idx], data, &i);
			else
				data->commands[cmd_idx].args = ft_extend_arr(
					data->commands[cmd_idx].args, data->tokens[i++].value);
		}
		if (i < data->token_count && data->tokens[i].type == PIPE)
			i++;
		cmd_idx++;
	}
	data->cmd_count = cmd_idx;
	return (0);
}

==> signals.c <==
#include "minishell.h"

int		rl_replace_line(const char *line, int clear_undo);

void sigint_handler(int sig)
{
   int g_signal = 0;
    (void)sig;
    write(1, "\n", 1);
    rl_replace_line("", 0);
    rl_on_new_line();
    rl_redisplay();
    g_signal = 130;
}

void setup_signals(void)
{
    struct sigaction sa;
    
    sa.sa_handler = sigint_handler;
    sa.sa_flags = SA_RESTART;
    sigemptyset(&sa.sa_mask);
    sigaction(SIGINT, &sa, NULL);
    signal(SIGQUIT, SIG_IGN);
}

==> syntax_check.c <==
#include "minishell.h"

/**
 * Print a more specific “unexpected token” error.
 */
static void print_unexpected_token(t_token_type type)
{
    if (type == PIPE)
        ft_putstr_fd("minishell: syntax error near unexpected token `|'\n", 2);
    else if (type == REDIR_IN)
        ft_putstr_fd("minishell: syntax error near unexpected token `<'\n", 2);
    else if (type == REDIR_OUT)
        ft_putstr_fd("minishell: syntax error near unexpected token `>'\n", 2);
    else if (type == REDIR_HEREDOC)
        ft_putstr_fd("minishell: syntax error near unexpected token `<<'\n", 2);
    else if (type == REDIR_APPEND)
        ft_putstr_fd("minishell: syntax error near unexpected token `>>'\n", 2);
}

/**
 * Disallow:
 *   - first or last token being a pipe
 *   - two pipes in a row
 *   - pipe with no command on either side
 */
static int check_pipes(t_data *data)
{
    int i;
    int prev_was_word;

    if (data->token_count == 0)
        return (1);

    if (data->tokens[0].type == PIPE)
    {
        print_unexpected_token(PIPE);
        return (0);
    }
    if (data->tokens[data->token_count - 1].type == PIPE)
    {
        print_unexpected_token(PIPE);
        return (0);
    }

    prev_was_word = 1;  // treat “before the first token” as a command boundary
    for (i = 1; i < data->token_count; i++)
    {
        if (data->tokens[i].type == PIPE)
        {
            if (!prev_was_word
                || data->tokens[i + 1].type == PIPE)
            {
                print_unexpected_token(PIPE);
                return (0);
            }
            prev_was_word = 0;
        }
        else
            prev_was_word = (data->tokens[i].type == WORD);
    }
    return (1);
}

/**
 * Disallow:
 *   - redir at start or end
 *   - redir not followed by a WORD
 *   - two redirs in a row
 */
static int check_redirs(t_data *data)
{
    int i;

    if (data->token_count == 0)
        return (1);

    /* 1) cannot start with a redirection */
    if (data->tokens[0].type >= REDIR_IN && data->tokens[0].type <= REDIR_HEREDOC)
    {
        print_unexpected_token(data->tokens[0].type);
        return (0);
    }

    i = 0;
    while (i < data->token_count)
    {
        if (data->tokens[i].type >= REDIR_IN
            && data->tokens[i].type <= REDIR_HEREDOC)
        {
            /* must not be last, and must be followed by WORD */
            if (i + 1 >= data->token_count
                || data->tokens[i + 1].type != WORD)
            {
                print_unexpected_token(data->tokens[i].type);
                return (0);
            }
            /* no two redirs back-to-back */
            if (i > 0
                && data->tokens[i - 1].type >= REDIR_IN
                && data->tokens[i - 1].type <= REDIR_HEREDOC)
            {
                print_unexpected_token(data->tokens[i].type);
                return (0);
            }
            i += 2;  // skip the filename
        }
        else
            i++;
    }
    return (1);
}

/**
 * Disallow any two non-WORD tokens in a row
 * (e.g. “| >”, “<< >>”, etc.)
 */
static int check_delimiter_sequences(t_data *data)
{
    int i;

    i = 1;
    while (i < data->token_count)
    {
        if (data->tokens[i].type != WORD
            && data->tokens[i - 1].type != WORD)
        {
            print_unexpected_token(data->tokens[i].type);
            return (0);
        }
        i++;
    }
    return (1);
}

/**
 * Main syntax validator.  On *any* failure we zero out cmd_count
 * so that free_data() won’t attempt to free stale parsed commands.
 */
int validate_syntax(t_data *data)
{
    if (!check_pipes(data)
        || !check_redirs(data)
        || !check_delimiter_sequences(data))
    {
        data->cmd_count = 0;
        return (0);
    }
    return (1);
}

==> utils.c <==
#include "minishell.h"

char	**ft_extend_arr(char **arr, char *new_str)
{
	char	**new;
	int		count;
	int		i;

	count = 0;
	while (arr && arr[count])
		count++;
	new = safe_malloc(sizeof(char *) * (count + 2));
	i = -1;
	while (++i < count)
		new[i] = arr[i];
	new[count] = ft_strdup(new_str);
	new[count + 1] = NULL;
	free(arr);
	return (new);
}

void	free_data(t_data *data)
{
	int	i;
	int	j;

	i = -1;
	while (++i < data->token_count)
		free(data->tokens[i].value);
	
	i = -1;
	while (++i < data->cmd_count)
	{
		ft_free_arr(data->commands[i].args);
		j = -1;
		while (++j < data->commands[i].redir_count)
			free(data->commands[i].redirs[j].file);
		free(data->commands[i].redirs);
	}
}

void    *safe_malloc(size_t size)
{
    void *ptr = malloc(size);
    if (!ptr)
    {
        write(2, "Malloc error\n", 13);
        exit(EXIT_FAILURE);
    }
    return (ptr);
}

char    *ft_strjoin_free(char *s1, char *s2, int free_flag)
{
    char    *result = ft_strjoin(s1, s2);
    if (free_flag & FIRST)
        free(s1);
    if (free_flag & SECOND)
        free(s2);
    return (result);
}

void	ft_free_arr(char **arr)
{
	int	i;

	i = 0;
	while (arr && arr[i])
		free(arr[i++]);
	free(arr);
}

==> minishell.h <==
#ifndef MINISHELL_H
# define MINISHELL_H

# include <stdlib.h>
# include <unistd.h>
# include <signal.h>
# include <readline/readline.h>
# include <readline/history.h>
# include "libft/libft.h"

# define MAX_TOKENS 100
# define MAX_COMMANDS 20
# define FIRST 1
# define SECOND 2
# define BOTH 3

typedef enum e_quote {
    NO_QUOTE,
    SINGLE_QUOTE,
    DOUBLE_QUOTE
}   t_quote;

typedef enum e_token_type {
    WORD,
    PIPE,
    REDIR_IN,
    REDIR_OUT,
    REDIR_APPEND,
    REDIR_HEREDOC
}   t_token_type;

typedef struct s_token {
    char            *value;
    t_token_type    type;
    t_quote         quote;  // New field
}   t_token;

typedef struct s_redir {
    char            *file;
    t_token_type    type;
}   t_redir;

typedef struct s_command {
    char **args;        // NULL-terminated array
    t_redir *redirs;    // Array of redirections
    int redir_count;
    int pipe_in;        // File descriptor for input pipe
    int pipe_out;       // File descriptor for output pipe
} t_command;

typedef struct s_data {
    t_token     tokens[MAX_TOKENS];
    int         token_count;
    t_command   commands[MAX_COMMANDS];
    int         cmd_count;
    char        **env;
    int         last_status;
}   t_data;

// Lexer
int     tokenize_input(char *input, t_data *data);

// Parser
int     parse_tokens(t_data *data);
int     validate_syntax(t_data *data);

// Expander
void    expand_tokens(t_data *data);

// Utils
void    free_data(t_data *data);
void    *safe_malloc(size_t size);
char    *ft_strjoin_free(char *s1, char *s2, int free_flag);
char	**ft_extend_arr(char **arr, char *new_str);
void    ft_free_arr(char **arr);

char    quote_type_to_char(t_quote type);
t_quote update_quote_state(t_quote current, char c);
char    *expand_variable(char **result, char *ptr, t_data *data);

// Signals
void    setup_signals(void);

#endif
==> Makefile <==
NAME = minishell

# Compiler
CC = cc
CFLAGS = -Wall -Wextra -Werror

# Source files
SRCS = main.c lexer.c parser.c signals.c utils.c expander.c syntax_check.c

# Object files
OBJS = $(SRCS:.c=.o)

# Includes
INCLUDES = -I. -I./libft

# Libraries
LIBS = -L./libft -lft -lreadline -I.brew/opt/readline/include -L/opt/vagrant/embedded/lib -lreadline

# Libft
LIBFT_DIR = ./libft
LIBFT = $(LIBFT_DIR)/libft.a

# Rules
all: $(LIBFT) $(NAME)

$(LIBFT):
	@make -C $(LIBFT_DIR)

$(NAME): $(OBJS) $(LIBFT)
	$(CC) $(CFLAGS) $(INCLUDES) -o $(NAME) $(OBJS) $(LIBS)

clean:
	rm -f $(OBJS)
	make clean -C $(LIBFT_DIR)

fclean: clean
	rm -f $(NAME)
	make fclean -C $(LIBFT_DIR)

re: fclean all

.PHONY: all clean fclean re
