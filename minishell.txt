==> expander.c <==
#include "minishell.h"
#include <stddef.h>

/**
 * get_env_value
 *   Find NAME=value in envp; returns pointer to value or NULL.
 */
char *get_env_value(char *name, char **env)
{
    size_t len = ft_strlen(name);

    for (int i = 0; env[i]; i++)
    {
        if (!ft_strncmp(env[i], name, len) && env[i][len] == '=')
            return (env[i] + len + 1);
    }
    return (NULL);
}

/**
 * expand_tokens
 *   Expand environment variables in each unquoted WORD token.
 */
t_error expand_tokens(t_data *data)
{
    for (int t = 0; t < data->token_count; t++)
    {
        t_token *tok = &data->tokens[t];
        if (tok->type != WORD || tok->quote == SINGLE_QUOTE)
            continue;

        /* initialize buffer */
        size_t cap = EXPAND_INIT_CAP;
        size_t len = 0;
        char *buf = safe_malloc(cap);
        buf[0] = '\0';

        char *src = tok->value;
        char quote = 0;

        for (size_t i = 0; src[i]; )
        {
            /* track quote state */
            if (!quote && (src[i] == '"' || src[i] == '\''))
            {
                quote = src[i++];
                continue;
            }
            else if (quote && src[i] == quote)
            {
                quote = 0;
                i++;
                continue;
            }

            /* variable expansion or literal '$' */
            if (src[i] == '$' && quote != '\'')
            {
                /* lookahead */
                char next = src[i + 1];

                /* literal '$' if no special var */
                if (next == '\0'
                 || (next != '?'
                  && !ft_isalnum(next)
                  && next != '_'))
                {
                    /* append '$' literally */
                    if (len + 1 >= cap)
                    {
                        buf = ft_realloc(buf, cap, cap * 2);
                        cap *= 2;
                    }
                    buf[len++] = src[i++];
                    continue;
                }

                /* skip '$' */
                i++;

                /* special $? */
                if (src[i] == '?')
                {
                    char *num = ft_itoa(data->last_status);
                    if(!num)
                    {
                        free(buf);
                        return ERR_MALLOC;
                    }
                    for (size_t j = 0; num[j]; j++)
                    {
                        if (len + 1 >= cap)
                        {
                            buf = ft_realloc(buf, cap, cap * 2);
                            cap *= 2;
                        }
                        buf[len++] = num[j];
                    }
                    free(num);
                    i++;
                    continue;
                }

                /* identifier var: gather its name */
                size_t start = i;
                while (src[i] && (ft_isalnum(src[i]) || src[i] == '_'))
                    i++;
                char *name = ft_substr(src, start, i - start);
                if (!name)
                {
                    free(buf);
                    return (ERR_MALLOC);
                }
                char *val  = get_env_value(name, data->env);
                free(name);

                /* append its value if any */
                if (val)
                {
                    for (size_t j = 0; val[j]; j++)
                    {
                        if (len + 1 >= cap)
                        {
                            buf = ft_realloc(buf, cap, cap * 2);
                            cap *= 2;
                        }
                        buf[len++] = val[j];
                    }
                }
                continue;
            }

            /* normal character copy */
            if (len + 1 >= cap)
            {
                buf = ft_realloc(buf, cap, cap * 2);
                cap *= 2;
            }
            buf[len++] = src[i++];
        }

        /* NUL terminate and replace */
        buf[len] = '\0';
        free(tok->value);
        tok->value = buf;
    }
    return SUCCESS;
}


==> main.c <==
#include "minishell.h"

// static void debug_print_tokens(t_data *data)
// {
//     printf("→ [debug] token_count = %d\n", data->token_count);
//     for (int i = 0; i < data->token_count; i++)
//     {
//         t_token *tok = &data->tokens[i];
//         printf("   token[%d]: type=%d, quote=%d, value=\"%s\"\n",
//                i, tok->type, tok->quote, tok->value ? tok->value : "NULL");
//     }
// }

// static void debug_print_commands(t_data *data)
// {
//     printf("→ [debug] cmd_count   = %d\n", data->cmd_count);
//     for (int c = 0; c < data->cmd_count; c++)
//     {
//         t_command *cmd = &data->commands[c];
//         printf("   command[%d]:\n", c);

//         if (cmd->args)
//         {
//             for (int j = 0; cmd->args[j]; j++)
//                 printf("      arg[%d] = \"%s\"\n", j, cmd->args[j]);
//         }
//         else
//             printf("      (no args)\n");

//         for (int r = 0; r < cmd->redir_count; r++)
//         {
//             printf("      redir[%d]: type=%d, file=\"%s\"\n",
//                    r, cmd->redirs[r].type, cmd->redirs[r].file);
//         }
//     }
// }

static void	cleanup_and_exit(t_data *data, int exit_code)
{
    free_data(data);
    clear_history();
    exit(exit_code);
}

int	main(int argc, char **argv, char **envp)
{
    t_data	data = {0};  // Initialize all fields to 0/NULL
    char	*input;

    (void)argc;
    (void)argv;
    data.env = envp;
    setup_signals();

    while (1)
    {
        data.syntax_error = 0;
        input = readline("minishell> ");

        /* Handle signals */
        if (g_signal)
        {
            data.last_status = g_signal;
            g_signal = 0;
            if (!input)
                write(1, "exit\n", 5);
        }

        if (!input)
        {
            write(1, "exit\n", 5);
            break;
        }

        if (*input)
        {
            add_history(input);
            t_error err = tokenize_input(input, &data);
            if (err != SUCCESS)
            {
                handle_error(err, &data, "tokenization");
                free(input);
                free_data(&data);
                continue;
            }

            // debug_print_tokens(&data);

            if (!validate_syntax(&data))
                handle_error(ERR_SYNTAX, &data, NULL);
            else
            {
                err = expand_tokens(&data);
                if (err != SUCCESS)
                    handle_error(err, &data, "expand");
                else if ((err = parse_tokens(&data)) != SUCCESS)
                    handle_error(err, &data, "parse");
                // else
                    // debug_print_commands(&data);
                    // execute_commands(&data);
            }
        }

        free(input);
        free_data(&data);
    }
    cleanup_and_exit(&data, data.last_status);
}

==> parser.c <==
#include "minishell.h"

static t_error ensure_command_capacity(t_data *data, int cmd_idx)
{
    int new_cap = data->cmd_cap ? data->cmd_cap * 2 : 16;

    if (cmd_idx >= data->cmd_cap)
    {
        data->commands = ft_realloc(
            data->commands,
            data->cmd_cap * sizeof(t_command),
            new_cap * sizeof(t_command)
        );
        for (int i = data->cmd_cap; i < new_cap; i++)
            data->commands[i] = (t_command){NULL, NULL, 0, 0, 0};
        data->cmd_cap = new_cap;
    }
    return (SUCCESS);
}

static t_error	add_redirection(t_command *cmd, t_data *data, int *i)
{
    if (*i + 1 >= data->token_count || data->tokens[*i + 1].type != WORD)
    {
        print_unexpected_token(data->tokens[*i].type);
        return (ERR_SYNTAX);
    }

    cmd->redirs = ft_realloc(
        cmd->redirs,
        cmd->redir_count * sizeof(t_redir),
        (cmd->redir_count + 1) * sizeof(t_redir)
    );
	char *file = ft_strdup(data->tokens[*i + 1].value);
    if (!file)
        return (ERR_MALLOC);
    cmd->redirs[cmd->redir_count] = (t_redir){.file = file, .type = data->tokens[*i].type};
    cmd->redir_count++;
    *i += 2;
    return (SUCCESS);
}

t_error parse_tokens(t_data *data)
{
    int cmd_idx = 0;
    int i = 0;

    free_commands(data);

    while (i < data->token_count)
    {
        ensure_command_capacity(data, cmd_idx);
        data->commands[cmd_idx] = (t_command){NULL, NULL, 0, 0, 0};

        while (i < data->token_count && data->tokens[i].type != PIPE)
        {
            if (data->tokens[i].type >= REDIR_IN)
            {
                t_error err = add_redirection(&data->commands[cmd_idx], data, &i);
                if (err != SUCCESS)
                    return (err);
            }
            else
            {
                data->commands[cmd_idx].args = ft_extend_arr(
                    data->commands[cmd_idx].args,
                    data->tokens[i++].value
                );
            }
        }
        if (i < data->token_count && data->tokens[i].type == PIPE)
            i++;
        cmd_idx++;
    }
    data->cmd_count = cmd_idx;
    return (SUCCESS);
}

==> signals.c <==
#include "minishell.h"

volatile sig_atomic_t g_signal = 0;

/**
 * sigint_handler
 *   Called on Ctrl-C in the interactive shell. Prints a newline,
 *   resets the readline prompt, and updates the shell's last status.
 */
static void	sigint_handler(int sig)
{
    (void)sig;
    write(1, "\n", 1);
    rl_replace_line("", 0);
    rl_on_new_line();
    rl_redisplay();
    g_signal = 130;  // POSIX standard for SIGINT
}

/**
 * setup_signals
 *   Installs sigint_handler for SIGINT, ignores SIGQUIT.
 */
void	setup_signals(void)
{
    struct sigaction	sa;
    struct sigaction	sa_quit;

    sa.sa_handler = sigint_handler;
    sa.sa_flags = SA_RESTART | SA_NODEFER;
    sigemptyset(&sa.sa_mask);
    if (sigaction(SIGINT, &sa, NULL) < 0)
    {
        ft_putstr_fd("minishell: failed to set SIGINT handler\n", 2);
        exit(EXIT_FAILURE);
    }

    sa_quit.sa_handler = SIG_IGN;
    sa_quit.sa_flags = 0;
    sigemptyset(&sa_quit.sa_mask);
    if (sigaction(SIGQUIT, &sa_quit, NULL) < 0)
    {
        ft_putstr_fd("minishell: failed to set SIGQUIT handler\n", 2);
        exit(EXIT_FAILURE);
    }
}

==> syntax_check.c <==
#include "minishell.h"

static t_error check_pipes(t_data *data)
{
    int i;
    int prev_was_word;

    if (data->token_count == 0)
        return (SUCCESS);
    if (data->tokens[0].type == PIPE
        || data->tokens[data->token_count - 1].type == PIPE)
    {
        print_unexpected_token(PIPE);
        return (ERR_SYNTAX);
    }
    prev_was_word = 1;
    i = 1;
    return (check_pipe_sequence(data, &i, &prev_was_word) ? SUCCESS : ERR_SYNTAX);
}

static t_error check_redirs(t_data *data)
{
    int i;

    if (data->token_count == 0)
        return (SUCCESS);
    if (data->tokens[0].type >= REDIR_IN
        && data->tokens[0].type <= REDIR_HEREDOC)
    {
        print_unexpected_token(data->tokens[0].type);
        return (ERR_SYNTAX);
    }
    i = 0;
    return (check_redir_sequence(data, &i) ? SUCCESS : ERR_SYNTAX);
}

static t_error check_delimiter_sequences(t_data *data)
{
    int i = 1;

    while (i < data->token_count)
    {
        if (data->tokens[i].type != WORD
            && data->tokens[i - 1].type != WORD)
        {
            print_unexpected_token(data->tokens[i].type);
            return (ERR_SYNTAX);
        }
        i++;
    }
    return (SUCCESS);
}

t_error validate_syntax(t_data *data)
{
    if (data->token_count == 1 && data->tokens[0].type == WORD
        && data->tokens[0].value[0] == '\0')
    {
        handle_error(ERR_CMD_NOT_FOUND, data, NULL);
        return (ERR_CMD_NOT_FOUND);
    }

    t_error err;
    if ((err = check_pipes(data)) != SUCCESS
        || (err = check_redirs(data)) != SUCCESS
        || (err = check_delimiter_sequences(data)) != SUCCESS)
    {
        data->last_status = err; // Directly use the error code
        return (err);
    }
    return (SUCCESS);
}

==> syntax_utils.c <==
#include "minishell.h"

void	print_unexpected_token(t_token_type type)
{
	if (type == PIPE)
		ft_putstr_fd("minishell: syntax error near unexpected token `|'\n", 2);
	else if (type == REDIR_IN)
		ft_putstr_fd("minishell: syntax error near unexpected token `<'\n", 2);
	else if (type == REDIR_OUT)
		ft_putstr_fd("minishell: syntax error near unexpected token `>'\n", 2);
	else if (type == REDIR_HEREDOC)
		ft_putstr_fd("minishell: syntax error near unexpected token `<<'\n", 2);
	else if (type == REDIR_APPEND)
		ft_putstr_fd("minishell: syntax error near unexpected token `>>'\n", 2);
}

t_error check_pipe_sequence(t_data *data, int *i, int *prev_was_word)
{
    while (*i < data->token_count)
    {
        if (data->tokens[*i].type == PIPE)
        {
            if (!(*prev_was_word) || (*i == data->token_count - 1))
            {
                print_unexpected_token(PIPE);
                return (ERR_SYNTAX);
            }
            *prev_was_word = 0;
        }
        else
            *prev_was_word = (data->tokens[*i].type == WORD);
        (*i)++;
    }
    return (SUCCESS);
}

t_error check_redir_sequence(t_data *data, int *i)
{
    while (*i < data->token_count)
    {
        if (data->tokens[*i].type >= REDIR_IN
            && data->tokens[*i].type <= REDIR_HEREDOC)
        {
            if (*i + 1 >= data->token_count
                || data->tokens[*i + 1].type != WORD)
            {
                print_unexpected_token(data->tokens[*i].type);
                return (ERR_SYNTAX);
            }
            if (*i > 0 && data->tokens[*i - 1].type >= REDIR_IN
                && data->tokens[*i - 1].type <= REDIR_HEREDOC)
            {
                print_unexpected_token(data->tokens[*i].type);
                return (ERR_SYNTAX);
            }
            *i += 2;
        }
        else
            (*i)++;
    }
    return (SUCCESS);
}

==> tokenizer.c <==
#include "minishell.h"

static int	ft_isspace(char c)
{
	return (c == ' ' || c == '\t' || c == '\n'
		|| c == '\v' || c == '\f' || c == '\r');
}

static char	quote_type_to_char(t_quote type)
{
	if (type == SINGLE_QUOTE)
		return ('\'');
	if (type == DOUBLE_QUOTE)
		return ('"');
	return (0);
}

static t_quote	update_quote_state(t_quote current, char c)
{
	if (c == '\'')
	{
		if (current == SINGLE_QUOTE)
			return (NO_QUOTE);
		return (SINGLE_QUOTE);
	}
	if (c == '"')
	{
		if (current == DOUBLE_QUOTE)
			return (NO_QUOTE);
		return (DOUBLE_QUOTE);
	}
	return (current);
}

static t_error	ensure_token_capacity(t_data *data)
{
	int	new_cap;

	if (data->token_count < data->token_cap)
		return (SUCCESS);
	if (data->token_cap > 0)
		new_cap = data->token_cap * 2;
	else
		new_cap = 16;
	data->tokens = ft_realloc(
		data->tokens,
		data->token_cap * sizeof *data->tokens,
		new_cap * sizeof *data->tokens
	);
	data->token_cap = new_cap;
	return (SUCCESS);
}

static t_error	add_token(t_data *data, char *value,
				t_token_type type, t_quote quote)
{
	if (ensure_token_capacity(data) != SUCCESS)
		return (ERR_MALLOC);
	if (type != WORD && !value)
	{
		if (type == PIPE)
			value = ft_strdup("|");
		else if (type == REDIR_IN)
			value = ft_strdup("<");
		else if (type == REDIR_OUT)
			value = ft_strdup(">");
		else if (type == REDIR_APPEND)
			value = ft_strdup(">>");
		else if (type == REDIR_HEREDOC)
			value = ft_strdup("<<");
		if (!value)
			return (ERR_MALLOC);
	}
	data->tokens[data->token_count++] =
		(t_token){value, type, quote};
	return (SUCCESS);
}

static t_error	handle_quotes(char *input, int *i, t_data *data)
{
	t_quote	quote_type;
	int		start;
	char	*value;

	quote_type = (input[*i] == '\'') ? SINGLE_QUOTE : DOUBLE_QUOTE;
	start = ++(*i);
	while (input[*i] && input[*i] != quote_type_to_char(quote_type))
		(*i)++;
	if (!input[*i])
	{
		ft_putstr_fd("minishell: unterminated quote\n", 2);
		data->syntax_error = 1;
		return (ERR_SYNTAX);
	}
	value = ft_substr(input, start, *i - start);
	if (!value)
		return (ERR_MALLOC);
	(*i)++;
	return (add_token(data, value, WORD, quote_type));
}

static t_error	handle_word(char *input, int *i, t_data *data)
{
	int		start;
	t_quote	quote;
	char	*value;

	start = *i;
	quote = NO_QUOTE;
	while (input[*i]
		&& ((quote != NO_QUOTE)
		|| (!ft_isspace(input[*i])
		&& !ft_strchr("|<>", input[*i]))))
	{
		if ((input[*i] == '\'' || input[*i] == '"')
			&& quote == NO_QUOTE)
			quote = update_quote_state(quote, input[*i]);
		else if (input[*i] == quote_type_to_char(quote))
			quote = update_quote_state(quote, input[*i]);
		(*i)++;
	}
	value = ft_substr(input, start, *i - start);
	if (!value)
		return (ERR_MALLOC);
	return (add_token(data, value, WORD, NO_QUOTE));
}

static t_error	handle_pipe(char *input, int *i, t_data *data)
{
	char	*pipe_str;
	t_error	err;

	(void)input;
	pipe_str = ft_strdup("|");
	if (!pipe_str)
		return (ERR_MALLOC);
	err = add_token(data, pipe_str, PIPE, NO_QUOTE);
	if (err != SUCCESS)
		free(pipe_str);
	(*i)++;
	return (err);
}

static t_error	handle_redirection(char *input, int *i, t_data *data)
{
	t_token_type	type;

	if (input[*i] == '<')
	{
		(*i)++;
		if (input[*i] == '<')
		{
			(*i)++;
			type = REDIR_HEREDOC;
		}
		else
			type = REDIR_IN;
	}
	else
	{
		(*i)++;
		if (input[*i] == '>')
		{
			(*i)++;
			type = REDIR_APPEND;
		}
		else
			type = REDIR_OUT;
	}
	return (add_token(data, NULL, type, NO_QUOTE));
}

t_error	tokenize_input(char *input, t_data *data)
{
	int		i;
	t_error	err;

	i = 0;
	err = SUCCESS;
	free_tokens(data);
	while (input[i] && err == SUCCESS)
	{
		if (ft_isspace(input[i]))
			i++;
		else if (input[i] == '\'' || input[i] == '"')
			err = handle_quotes(input, &i, data);
		else if (input[i] == '|')
			err = handle_pipe(input, &i, data);
		else if (input[i] == '<' || input[i] == '>')
			err = handle_redirection(input, &i, data);
		else
			err = handle_word(input, &i, data);
	}
	if (err == SUCCESS && data->syntax_error)
		err = ERR_SYNTAX;
	return (err);
}

==> utils.c <==
#include "minishell.h"

/**
 * safe_malloc
 *   malloc wrapper that exits(1) on failure.
 */
void	*safe_malloc(size_t size)
{
	void	*ptr;

	ptr = malloc(size);
	if (!ptr)
	{
		write(2, "Malloc error\n", 13);
		exit(EXIT_FAILURE);
	}
	return (ptr);
}

/**
 * ft_realloc
 *   Grow or shrink a block at ptr (of old_size) to new_size,
 *   exiting on allocation failure.
 */
void	*ft_realloc(void *ptr, size_t old_size, size_t new_size)
{
	void	*new_ptr;

	if (!ptr)
		return (safe_malloc(new_size));
	if (new_size == 0)
	{
		free(ptr);
		return (NULL);
	}
	new_ptr = safe_malloc(new_size);
	ft_memcpy(new_ptr, ptr, old_size);
	free(ptr);
	return (new_ptr);
}

/*
** ft_extend_arr
**   Append new_str to a NULL-terminated array of strings.
**   Returns the new array (old one is freed).  Exits on alloc failure.
*/
char	**ft_extend_arr(char **arr, char *new_str)
{
	int		count;
	int		i;
	char	**new;

	count = 0;
	while (arr && arr[count])
		count++;
	new = safe_malloc(sizeof(char *) * (count + 2));
	i = 0;
	while (i < count)
	{
		new[i] = arr[i];
		i++;
	}
	new[count] = ft_strdup(new_str);
	new[count + 1] = NULL;
	free(arr);
	return (new);
}

void	append_char(char **buf, size_t *cap, size_t *len, char c)
{
	if (*len + 1 >= *cap)
	{
		*buf = ft_realloc(*buf, *cap, *cap * 2);
		*cap *= 2;
	}
	(*buf)[(*len)++] = c;
	(*buf)[*len] = '\0';
}

void	handle_error(t_error err, t_data *data, char *context)
{
	char	*msg;
	int		status;

	msg = NULL;
	status = err;
	if (err == ERR_SYNTAX)
		msg = "syntax error";
	else if (err == ERR_MALLOC)
		msg = "memory allocation failed";
	else if (err == ERR_CMD_NOT_FOUND)
		msg = "command not found";
	else if (err == ERR_SIGINT)
	{
		msg = "";
		status = 130;
	}
	else
		msg = "unknown error";
	ft_putstr_fd("minishell: ", STDERR_FILENO);
	if (context)
	{
		ft_putstr_fd(context, STDERR_FILENO);
		ft_putstr_fd(": ", STDERR_FILENO);
	}
	if (*msg)
		ft_putendl_fd(msg, STDERR_FILENO);
	data->last_status = status;
}

==> utils_free.c <==
#include "minishell.h"

void	free_tokens(t_data *data)
{
	int	i;

	if (data->tokens)
	{
		i = 0;
		while (i < data->token_count)
		{
			free(data->tokens[i].value);
			i++;
		}
		free(data->tokens);
	}
	data->tokens     = NULL;
	data->token_count = 0;
	data->token_cap   = 0;
}

void	free_commands(t_data *data)
{
	int	c;
	int	r;

	if (data->commands)
	{
		c = 0;
		while (c < data->cmd_count)
		{
			ft_free_arr(data->commands[c].args);
			r = 0;
			while (r < data->commands[c].redir_count)
			{
				free(data->commands[c].redirs[r].file);
				r++;
			}
			free(data->commands[c].redirs);
			c++;
		}
		free(data->commands);
	}
	data->commands = NULL;
	data->cmd_count = 0;
	data->cmd_cap   = 0;
}

void	free_data(t_data *data)
{
	free_tokens(data);
	free_commands(data);
}

void	ft_free_arr(char **arr)
{
	int	i;

	if (!arr)
		return ;
	i = 0;
	while (arr[i])
	{
		free(arr[i]);
		i++;
	}
	free(arr);
}

==> minishell.h <==
#ifndef MINISHELL_H
# define MINISHELL_H

# include "libft/libft.h"
# include <readline/history.h>
# include <readline/readline.h>
# include <signal.h>
# include <stddef.h>
# include <stdlib.h>
# include <unistd.h>

extern volatile sig_atomic_t g_signal;

/* Maximum initial buffer for expansion */
# define EXPAND_INIT_CAP 64

typedef enum e_quote
{
	NO_QUOTE,
	SINGLE_QUOTE,
	DOUBLE_QUOTE
}					t_quote;

typedef enum e_token_type
{
	WORD,
	PIPE,
	REDIR_IN,
	REDIR_OUT,
	REDIR_APPEND,
	REDIR_HEREDOC
}					t_token_type;

typedef struct s_token
{
	char			*value;
	t_token_type	type;
	t_quote			quote;
}					t_token;

typedef struct s_redir
{
	char			*file;
	t_token_type	type;
}					t_redir;

typedef struct s_command
{
	char			**args;
	t_redir			*redirs;
	int				redir_count;
	int				pipe_in;
	int				pipe_out;
}					t_command;


typedef struct s_data
{
	t_token			*tokens;
	int				token_count;
	int				token_cap;
	t_command		*commands;
	int				cmd_count;
	int				cmd_cap;
	char			**env;
	int				last_status;
	int				syntax_error;
	char		*input;
	volatile sig_atomic_t	signal_status; 
}					t_data;

typedef enum e_error
{
	SUCCESS = 0,
	ERR_SYNTAX = 2, // Bash-compatible syntax error
	ERR_CMD_NOT_FOUND = 127,
	ERR_SIGINT = 130,  // Ctrl-C exit code
	ERR_SIGQUIT = 131, // Ctrl-\ exit code
	ERR_MALLOC = 255   // Internal error (not POSIX)
	// Add others as needed (e.g., file not found, permission denied)
}					t_error;

/* core */
t_error				tokenize_input(char *input, t_data *data);
t_error				parse_tokens(t_data *data);
t_error				validate_syntax(t_data *data);
t_error				expand_tokens(t_data *data);
void				setup_signals(void);

/* utils */
void				*safe_malloc(size_t size);
void				*ft_realloc(void *ptr, size_t old_size, size_t new_size);
char				**ft_extend_arr(char **arr, char *new_str);
void				append_char(char **buf, size_t *cap, size_t *len, char c);

/* expander helpers */
char	*get_env_value(char *name, char **env); // searches envp[]

/* syntax check */
void				print_unexpected_token(t_token_type type);
t_error				check_redir_sequence(t_data *data, int *i);
t_error				check_pipe_sequence(t_data *data, int *i,
						int *prev_was_word);

/* readline integration */
int					rl_replace_line(const char *text, int clear_undo);
void				rl_redisplay(void);

void				free_commands(t_data *data);
void				free_tokens(t_data *data);
void				free_data(t_data *data);
void				ft_free_arr(char **arr);
void				handle_error(t_error err, t_data *data, char *context);

#endif

==> Makefile <==
NAME = minishell

# Compiler
CC = cc
CFLAGS = -Wall -Wextra -Werror

# Directories
SRCDIR = .
BUILDDIR = build
LIBFT_DIR = ./libft

# Source files (explicitly listed)
SRCS = main.c \
	tokenizer.c \
	parser.c \
	signals.c \
	utils.c \
	utils_free.c \
	expander.c \
	syntax_check.c \
	syntax_utils.c

# Object files in build/
OBJS = $(SRCS:%.c=$(BUILDDIR)/%.o)

# Includes and libraries
INCLUDES = -I. -I./libft
LIBS = -L./libft -lft -lreadline -I.brew/opt/readline/include -L/opt/vagrant/embedded/lib -lreadline
LIBFT = $(LIBFT_DIR)/libft.a

# Rules
all: $(LIBFT) $(NAME)

$(LIBFT):
	@make -C $(LIBFT_DIR)

$(BUILDDIR):
	@mkdir -p $(BUILDDIR)

$(BUILDDIR)/%.o: %.c | $(BUILDDIR)
	$(CC) $(CFLAGS) $(INCLUDES) -c $< -o $@

$(NAME): $(OBJS) $(LIBFT)
	$(CC) $(CFLAGS) $(INCLUDES) -o $(NAME) $(OBJS) $(LIBS)

clean:
	rm -rf $(BUILDDIR)
	make clean -C $(LIBFT_DIR)

fclean: clean
	rm -f $(NAME)
	make fclean -C $(LIBFT_DIR)

re: fclean all

.PHONY: all clean fclean re
